class Solution {
public:
    typedef long long ll;
    typedef pair<int,char>p;
    void Dijsktra(char src,vector<vector<int>>&costmatrix, unordered_map<char,vector<pair<char,int>>>&graph){
        priority_queue<p,vector<p>,greater<p>>pq;
        pq.push({0,src});
        while(!pq.empty()){
            int currcost = pq.top().first;
            int currnode = pq.top().second;
            pq.pop();
            for (auto &x : graph[currnode]){
                char nextnode = x.first;
                int nextcost  = x.second;
                if (costmatrix[src-'a'][nextnode-'a'] > currcost + nextcost){
                    costmatrix[src-'a'][nextnode-'a'] = currcost + nextcost;
                    pq.push({currcost+nextcost,nextnode});
                }
            }
        }
        return;
    }
    long long minimumCost(string source, string target, vector<char>& original, vector<char>& changed, vector<int>& cost) {

        unordered_map<char,vector<pair<char,int>>>graph;
        for (int i=0; i<original.size(); i++){
            graph[original[i]].push_back({changed[i],cost[i]});
        }
        vector<vector<int>>costmatrix(26,vector<int>(26,INT_MAX));

        for (int i=0; i<source.size(); i++){
            Dijsktra(source[i],costmatrix,graph);
        }

        ll min_cost = 0;
        for (int i=0; i<source.size(); i++){
            if (source[i] == target[i]) continue;
            else if (costmatrix[source[i]-'a'][target[i]-'a'] == INT_MAX) return -1;
            else min_cost += (ll) costmatrix[source[i]-'a'][target[i]-'a'];
        }
        return min_cost;
        
    }
};
